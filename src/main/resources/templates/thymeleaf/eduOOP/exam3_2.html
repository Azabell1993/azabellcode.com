
<!-- Preformatted Code -->
<br/>
<h2>2. JAVA언어 스타일 구조체 구성</h2>
<br/>
<div class="col-10 col-12-medium">
    <ul class="alt">
        <li>JAVA는 기본적으로 설계언어로 알려져있다.</li>
        <li>C언어와는 반대로 객체지향형을 기본적으로 삼고 있는 프로그램 언어이기 때문에 Class로 선언하면서 운을 떼었다.</li></li>
    </ul>
</div>

<!-- Preformatted Code -->
<pre><code>public class CalculatorClass {
	
// 필드 선언
public double input_NumA;
public double input_NumB;
public char op;
public double result;

// 메서드 선언
}
</code></pre>
<!-- Preformatted Code -->

<div class="col-10 col-12-medium">
    <ul class="alt">
        <li>간결하게 보여진다. 다만, C와 다른 점이라면, <strong>완전한 객체지향형 언어</strong>이기 때문에 클래스 내에서 함수들을 그냥 넣어줘도 무방하다.</li>
        <li>JAVA에서 구현한 `생성자` 함수는 아래와 같으나, 본 예제에서는 굳이 넣지 않아도 실행에는 지장이 없다. 우선 `생성자`라는 개념을 잡기 위해서는 아래를 참조하면 된다.</li>
        <li><code>생성자란 인스턴스가 생성될 때 필드를 초기화 하기 위한 것이다.</code></li>
    </ul>
</div>

<!-- Preformatted Code -->
<pre><code>CalculatorClass() {
    super();
}

public CalculatorClass(double input_NumA, double input_NumB, char op, double result) {
    super();
    this.input_NumA = input_NumA;
    this.input_NumB = input_NumB;
    this.op = op;
    this.result = result;
}

// 생성자란 인스턴스가 생성될 때 필드를 초기화 하기 위한 것이다.
// 이 생성자 두 함수는 주석처리를 하여도 컴파일 및 구동에는 전혀 지장이 없다.
// 왜냐하면 본 예제에서는 생성자를 사용하여 오버로딩을 할 필요 또한 전혀 없기 때문이다.
// 외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화하려면 오버로딩을 해야한다.
</code></pre>
<!-- Preformatted Code -->

<div class="col-10 col-12-medium">
    <ul class="alt">
        <li> 이제 JAVA에서 짠 가산기의 소스코드 4가지 함수를 살펴보자.</li>
    </ul>
</div>

<!-- Preformatted Code -->
<pre><code>public void add() {
    result = input_NumA + input_NumB;
    System.out.println(input_NumA + " + " + input_NumB + " = " + result);
} 

public void sub() {
    result = input_NumA - input_NumB;
    System.out.println(input_NumA + " - " + input_NumB + " = " + result);
} 

public void mul() {
    result = input_NumA * input_NumB;
    System.out.println(input_NumA + " * " + input_NumB + " = " + result);
} 

public void div() {
    result = input_NumA / input_NumB;
    System.out.println(input_NumA + " / " + input_NumB + " = " + result);
}
</code></pre>
<!-- Preformatted Code -->

<div class="col-10 col-12-medium">
    <ul class="alt">
        <li><code>System.out.println</code>의 경우에는 C에서처럼 <code>init</code>함수를 따로 만들어서 구현을 하여도 상관이 없으나, C와 비교하자는 점에서 이해를 돕기 위해 우선 가산기 함수 내에서 출력함수를 구현하였다. 
        <li>어차피 <code>getter</code> 함수 내에서 <code>init한 함수</code>를 불러와서 <code>출력 함수를 실행</code>하기 때문에 순서는 어디에 넣어도 무방하리라고 생각한다.</li>
        <li><code>setter</code>함수와 <code>getter</code> 함수는 아래와 같다.</li>
    </ul>
</div>

<!-- Preformatted Code -->
<pre><code>// setter 함수
private void setInput_Values(double input_NumA2, char op2, double input_NumB2, double result2) {
    if(op == '+') { add(); }
    else if(op == '-') { sub(); }
    else if(op == '*') { mul(); }
    else if(op == '/') { div(); }
    return;
}

// getter 함수
public void getInput_Values(double input_NumA2, char op2, double input_NumB2, double result2) {
    setInput_Values(this.input_NumA, this.op, this.input_NumB, this.result);
}
</code></pre>
<!-- Preformatted Code -->

<div class="col-10 col-12-medium">
    <ul class="alt">
        <li>앞서 C언어에서는 <code>setter</code> 대신에 <code>init</code>함수를 만들어서 먼저 연산자를 조건 분기로 판별을 하였으나,</li>
        <li>본 JAVA언어에서는 <code>setter</code> 함수에서 먼저 조건분기로 판별을 한 후, 함수가 호출하는 방향으로 설계해봤다.</li>
    </ul>
</div>
