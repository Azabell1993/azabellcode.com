
    <div class="col-12 col-12-medium">
        <h2></h2>
        <h3>이 설명글은 온전히 필자의 경험을 바탕하에 저술한 글이다. 따라서 이 글은 그냥 공부를 하는데에 있어서 참고용 정도로 읽어주면 좋겠다.</h3>
    </div>
    
    <div class="col-10 col-12-medium">
        <h4>포인터를 잘 알아야하는 이유</h4>
        <ul>
            <li> 코드만으로는 최적화가 힘들때 레지스터 구조를 이용하여서 어셈블리 언어를 작성하는 경우가 종종 있다.</li>
            <li> 작고 간결한 표현의 사용</li>
            <li> 선언한 변수의 명시적 선언으로 메모리를 아낄 수 있다.</li>
            <li> 빠르고 효율적인 코드 작성(메모리 절감)</li>
            <li> 코드만으로는 최적화가 힘들때 레지스터 구조를 이용하여서 어셈블리 언어를 작성하는 경우가 종종 있다.</li>
            <li> 작고 간결한 표현의 사용</li>
            <li> 선언한 변수의 명시적 선언으로 메모리를 아낄 수 있다.</li>
            <li> 빠르고 효율적인 코드 작성(메모리 절감)</li>
        </ul>
    </div>

    <div class="col-10 col-12-medium">
        <ul class="alt">
            <li>예를 들어서 strcpy, strncpy, memcpy 등등이 있다.</li>
            <li>포인터 표현 방식은 배열보다 더 명확하고 유연하다. 배열의 크기는 일반적으로 배열이 생성될 때 결정되어 배열이 저장할 수 있는 요소의 수에 제약이 발생한다. (즉, 배열은 '상수'고 포인터는 '변수'다)</li>
            <li>포인터를 활용하면 이런 제약이 일절 생기지 않으며, 새로운 node가 필요할 때 동적으로 할당할 수 있다.</li>
            <li>포인터의 연결리스트는 NULL이 될때까지 효과적으로 활용이 가능한 것이고, 배열의 사용은 좀 정적(static)인 느낌으로 구성이 되어있다.</li>
        </ul>
    </div>

    <div class="box alt">
        <div class="row gtr-50 gtr-uniform">
            <div class="col-4"><span class="image fit"><img src="images/pointer_(1).png" alt="" /></span></div>
            <p><strong>정적 포인터</strong></p>
            <div class="col-4"><span class="image fit"><img src="images/pointer_(2).png" alt="" /></span></div>
            <p><strong>동적 포인터</strong></p>
        </div>
    </div>

    <div class="col-10 col-12-medium">
        <ul class="alt">
            <li>포인터에 대해서 개념을 얼마나 확실하고 정확하게 이해했는 지에 따라서 프로그래머의 실력/방향성(잠재력)이 달라질 수 있다고 생각한다.</li>
            <li>c언어를 처음에 접할때 우선 간단하게 변수의 개념부터 배우게 되는데, 변수라 함은 값이 유동적으로 변할 수 있음을 뜻한다. </li>
            <li>초보가 사용하기 편하게 값이 유동적으로 변하는 개념부터 학습 시키는 것이 일반적이다.</li>
        </ul>
    </div>
<!-- Preformatted Code -->
<pre><code>int a; //정수 a의 변수 선언.			
</code></pre>
<!-- Preformatted Code -->

    <div class="col-10 col-12-medium">
        <ul class="alt">
            <li>그리고 위의 내용을 배우면 아래의 내용을 보게 되는데,</li>
        </ul>
    </div>

<!-- Preformatted Code -->
<pre><code>printf(); //출력 함수
scanf(); //인자 값 받는 함수		
</code></pre>
<!-- Preformatted Code -->

    <div class="col-10 col-12-medium">
        <ul class="alt">
            <li>이 두 개의 함수부터 배운다.</li>
        </ul>
    </div>

<!-- Preformatted Code -->
<pre><code>printf("hello world!\n"); //\n은 개행이라는 아스키 문자다.
</code></pre>
<!-- Preformatted Code -->

    <div class="col-10 col-12-medium">
        <ul class="alt">
            <li>사실 C프로그램을 처음 접할때부터 이미 포인터를 배운다.</li>
        </ul>
    </div>

<!-- Preformatted Code -->
<pre><code>int a; //변수 a가 있으면
a = 10; //a를 10으로 선언해주고
printf("%d\n", a); //a를 출력해준다.
///////////////////////////////////////////////////
int b; //입력받을 인자 값 변수명을 선언해주고
scanf("%d", &b); //b를 임시적으로 넣으면서 주소값 &를 할당시켜 값을 받게 한다.
</code></pre>
<!-- Preformatted Code -->

<div class="col-10 col-12-medium">
<ul class="alt">
<li>바로 scanf함수에서의 &기호에서 이미 학습은 끝이 난 것이다. 되게 쉽다.
<li>그런데 왜 나중에 뒤에 가서 *로 고통을 받는 것일까??</li>
<li>그것은 바로 레지스터 구조와 컴퓨터의 원리, 그리고 저 함수들이 어떻게 프로그래밍 되는지에 대해서 이해를 못했기 때문에 포인터가 어렵게 느껴지는 것이다.</li>
<li>필자는 코드 자체가 포인터로 보여진다. 포인터라함은 간단하게 설명하여서 메모리 위치의 주소를 저장하는 변수이다.</li>
<li>그렇다면 상수는 포인터가 아닌가? '주소'자체를 저장함에 있어서는 포인터라고 할 수 있지만 그 형태가 약간 다르다는 것이다.</li>
<li>이제 포인터에 대해서 자세히 알아보자.</li>
<br>
<li><strong>1. 정적(Static)/전역(Global)</strong></li>
<li>정적으로 선언된 변수들은 정적/전역 메모리에 할당된다.</li>
<li><strong>2. 자동(Automatic)/로컬(Local)</strong></li>
<li>자동 변수는 함수 안에서 선언되고 함수가 호출될 때 생성된다.</li>
<li><strong>3. 동적(Dynamic)</strong></li>
<li>동적 메모리는 힙 메모리 영역에 할당되고 필요한 경우 해제된다. 이 개념에 대해서는 자료구조에서 자세하게 나온다.</li>
    <br>
    <li><strong>접근 범위(Scope)와 수명(Lifetime)</strong></li>
    
        <div class="table-wrapper">
            <table>
                <thead>
                    <tr>
                        <th></th>
                        <th>접근  범위</th>
                        <th>수		명</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>전역</td>
                        <td>전체 파일</td>
                        <td>애플리케이션 실행 동안 유지</td>
                    </tr>
                    <tr>
                        <td>정적</td>
                        <td>선언된 함수</td>
                        <td>애플리케이션 실행 동안 유지</td>
                    </tr>
                    <tr>
                        <td>자동(로컬)</td>
                        <td>선언된 함수</td>
                        <td>함수 실행 동안 유지</td>
                    </tr>
                    <tr>
                        <td>동적</td>
                        <td>참조하는 포인터</td>
                        <td>메모리 해제 전까지 유지</td>
                    </tr>
                </tfoot>
            </table>
        </div>
    <br>
<li>포인터 변수는 레지스터 구조상 메모리 주소를 포함하고 있으며 이 객체는 malloc 따위의 함수를 구현하여 할당된 메모리라고도 할 수 있다.</li>
<li>포인터는 하드웨어 구조에 많이 가깝다. 필자는 개인적으로 많이 가깝다기보다는 아예 그 자체로 보고있다.</li>
<li>아래를 보자.</li>
<li>우선 마이크로컨트롤러의 CPU는 RISC(Reduced Instruction Set Computer)구조를 사용하는 경우가 많고, </li>
<li>데스크톱 컴퓨터에 사용되는 인텔의 CPU는 CISC(Complex Instruction Set Computer) 구조를 사용한다.</li>
<li>CISC와 RISC의 가장 큰 차이는 CPU에서 지원하는 명령어 개수에 있는데 여기서 말하는 명령어는 로우레벨 수준의 명령어인 Assembly langauge를 의미한다. </li>
<li>이 것도 포인터라고 볼 수 있다. 왜냐면 메모리에 저장하는 변수들이기 때문이다. (상수도 있을 수 있지만 사용자 임의대로 변수로 바꿀 수 있으니 우선 포괄적으로 말하겠다.)</li></li>
<br>

<li><strong>CISC 구조 어셈블리 명령</strong></li>
<li>M: 메모리, R: 레지스터</li>

<!-- Preformatted Code -->
<pre><code>ADD R1, A, B      ;R1 ← M[A] + M[B]
ADD R2, C, D      ;R2 ← M[C] + M[D]
MUL X, R1, R2     ;M[X] ← R1 * R2		
</code></pre>
<!-- Preformatted Code -->	

<li>RISC 구조에서의 어셈블리 명령</li>

<!-- Preformatted Code -->
<pre><code>ADD R1, A, B      ;R1 ← M[A] + M[B]
ADD R2, C, D      ;R2 ← M[C] + M[D]
MUL X, R1, R2     ;M[X] ← R1 * R2		
</code></pre>
<!-- Preformatted Code -->	

<li>각 각  CPU 마다 어셈블리 구조는 다르다.</li>

<div class="box alt">
    <div class="row gtr-10 gtr-uniform">
        <div class="col-10"><span class="image fit"><img src="images/pointer_(3).png" alt="" /></span></div>
        <p><strong>assembly langague</strong></p>
    </div>
</div>

<li>먼저 이것을 보여주는 이유는, 포인터는 데이터의 위치를 가리키는 변수이긴 하지만 정확히 무슨 말인지 모를 것이다.</li>
<li>우선 비전공자가 이것을 이해할려면 하드웨어의 레지스터를 정확히 이해할 필요가 있다.</li>
<li><h3><strong>모든 위치는 메모리의 주소로 결정된다.</strong></h3></li>

<div class="box alt">
    <div class="row gtr-10 gtr-uniform">
        <div class="col-10"><span class="image fit"><img src="images/pointer_(4).png" alt="" /></span></div>
        <div class="col-10"><span class="image fit"><img src="images/pointer_(5).png" alt="" /></span></div>
    </div>
</div>

<li>포인터를 이해하기 전에 반드시 이 그림의 32비트 CPU와 메모리간의 데이터 엑세스를 위한 구조가 어떤 것인지 이해를 필요가 있다.</li>
<li>각각 주소값이 메모리 주소 0x00000000, 0x00000001 따위의 주소에 저장이 된다.</li>
<li>이게 포인터다.</li>
<li>그렇기 때문에 포인터를 이해하기 전에 메모리와 레지스터간의 데이터 엑세스를 이해 해야 한다. C는 기계어와 밀접한 관계를 가지고 있으며 좀더 로우레벨에 가까우면서도 저레벨로 언어 프로그래밍이 가능한 유일한 언어다.</li>
<br>
<li>조금 더 자세하게 해부를 해보자면, 아래의 이미지를 보면 된다.</li>
<li>아래의 자료는 폰 노이만 memory map 구조(struct)를 갖는 MCU의 Ti사 TMS320F28335다.</li>

<div class="box alt">
    <div class="row gtr-10 gtr-uniform">
        <div class="col-10"><span class="image fit"><img src="images/pointer_(6).png" alt="" /></span></div>
        <p><strong>TMS320F28335</strong></p>
    </div>
</div>

<li>이렇게 각각의 영역에서 Data Memory영역은 0x00000000 ~ 0x00F00000</li>
<li>Program Memroy 영역은 0x30000000~0x3300FFF8 로 이뤄져있다.</li>
<li>이처럼 포인터로 사용할 변수는 이렇게 하드웨어 구조상으로 이뤄져 있다고 보면 되고, 이를 직접 상세하게 로우레벨로 다루는 언어는 어셈블리 언어가 유일하다. C언어와 C++언어는 메모리 누수가 터지기도 쉽고 사고가 나면 수습하기도 힘든 언어이다. (그래서 Rust가 있다.)</li>
<li>이제 다시 C언어로 돌아와서 예를 들어야 될 것 같다.</li>

<!-- Preformatted Code -->
<pre><code>int C_lang_value;
C_lang_value = 10;	
</code></pre>
<!-- Preformatted Code -->	

<li>만약 이렇게 변수 하나를 선언하고 이 변수의 주소값이 레지스터 0x00400100 에 저장이 된다고 가정하면 이 변수의 주소값이 0x00400100이라는 의미다.</li>

<!-- Preformatted Code -->
<pre><code>mov VL, #0x00400100
mov (VL), #10	
</code></pre>
<!-- Preformatted Code -->	

<li>풀이를 하자면 어셈블리에서의 변수는 VL로 선언을 하였고 0x00400100의 값을 VL에 넣고, VL이 가리키는 주소에 10을 대입하라는 의미다. </li>
<li>아래의 이미지에서 더 자세하게 볼 수 있다.</li>
<br>
<div class="row gtr-200">
    <div class="col-10 col-12-medium">
        <div class="box alt">
            <div class="row gtr-30 gtr-uniform">
                <div class="col-10"><span class="image fit"><img src="images/pointer_reverse(1).png" alt="" /></span></div>
                <div class="col-6"><span class="image fit"><img src="images/pointer_reverse(2).png" alt="" /></span></div>
                <div class="col-6"><span class="image fit"><img src="images/pointer_reverse(3).png" alt="" /></span></div>
                <div class="col-6"><span class="image fit"><img src="images/pointer_reverse(4).png" alt="" /></span></div>
                <div class="col-6"><span class="image fit"><img src="images/pointer_reverse(5).png" alt="" /></span></div>
            </div>
        </div>
    </div>
</div>

<li>직관적으로 느끼셨겠지만, 대락 이런 구조로 메모리를 저장해가면서 완성이 되는 구조다.</li>
<li>위에서 봤겠지만, CPU마다 어셈블리 명령어는 다르다.</li>
<li>이렇게 변수를 하나 지정하면 레지스터가 알아서 주소값을 찾아서 자동으로 지정을 해준다. 변수값의 주소는 컴퓨터가 무작위로 지정을 해주지만, <strong>우리는 그 무작위로 지정이 되는 변수를 명시적으로 활용을 할 수가 있다.</strong></li>
<li>그게 바로 <strong>포인터(*)</strong>다.</li>

<!-- Preformatted Code -->
<pre><code>int C_lang_value;
C_lang_value = 10;

int* Ptr;
</code></pre>
<!-- Preformatted Code -->	

<li>포인터 변수 Ptr를 하나 추가하였다. 그리고 C_lang_value의 값을 명시적으로 가져와보자.</li>

<!-- Preformatted Code -->
<pre><code>int C_lang_value;
C_lang_value = 10;

int* Ptr;
*Ptr = &C_lang_value;
</code></pre>
<!-- Preformatted Code -->	

<li>이렇게 명시적으로 가져와서 활용을 해줄 수 있는 것이 <strong>포인터(*)</strong>다.</li>
<li>알고보면 엄청 쉽다. 2차원으로 풀면</li>
<strong><code>int** ptr;</code></strong><br>
<li>이렇게 선언이 가능해지는 것이다. 이제 <strong>%p</strong> 선언으로 주소값을 표현하여보자.</li>

<!-- Preformatted Code -->
<pre><code>#include &lt;stdio.h&gt;

int main() {
int* p = NULL;
int i = 10;
p = &i;

printf("변수 i의 주소값 : %p \n", &i);
printf("포인터 p의 값 : %p \n", p);
printf("포인터 p이 가리키는 값 : %d \n", *p);

return 0;
}
</code></pre>
<!-- Preformatted Code -->	

<li><strong>결과 값</strong></li>
<div class="box">
<p>PS D:\CPP\POINTER_LATURE> & .\"pointer.exe"<br>
변수 i의 주소값 : 0061FF18<br>
포인터 p의 값 : 0061FF18 <br>
포인터 p이 가리키는 값 : 10</p>
</div>


<li>이처럼 포인터는 대상을 명시적으로 기리키는 개념으로 이해를 하면 좋다.</li>
<li>다음 편에서는 포인터의 활용 예들을 정리해보겠다.</li>


</ul>
</div>
